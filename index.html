<!DOCTYPE html>
<html lang="en">

<head>
    <title>Bootstrap Example</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script>
        "use strict";
        (function (root, factory) {
            if ((typeof define === 'function') && define.amd) {
                define([], factory);
            } else if ((typeof module === 'object') && module.exports) {
                module.exports = factory();
            } else {
                root.pureknob = factory();
            }
        }(typeof self !== 'undefined' ? self : this, function () {
            function PureKnob() {
                this.createBarGraph = function (width, height) {
                    const heightString = height.toString();
                    const widthString = width.toString();
                    const canvas = document.createElement('canvas');
                    const div = document.createElement('div');
                    div.style.display = 'inline-block';
                    div.style.height = heightString + 'px';
                    div.style.position = 'relative';
                    div.style.textAlign = 'center';
                    div.style.width = widthString + 'px';
                    div.appendChild(canvas);
                    const graph = {
                        '_canvas': canvas,
                        '_div': div,
                        '_height': height,
                        '_width': width,
                        '_properties': {
                            'colorBG': '#181818',
                            'colorFG': '#ff8800',
                            'colorMarkers': '#888888',
                            'markerStart': 0,
                            'markerEnd': 100,
                            'markerStep': 20,
                            'trackWidth': 0.5,
                            'valMin': 0,
                            'valMax': 100,
                            'valPeaks': [],
                            'val': 0
                        },
                        'getPeaks': function () {
                            const properties = this._properties;
                            const peaks = properties.valPeaks;
                            const numPeaks = peaks.length;
                            const peaksCopy = [];
                            for (let i = 0; i < numPeaks; i++) {
                                const peak = peaks[i];
                                peaksCopy.push(peak);
                            }
                            return peaksCopy;
                        },
                        'getProperty': function (key) {
                            const properties = this._properties;
                            const value = properties[key];
                            return value;
                        },
                        'getValue': function () {
                            const properties = this._properties;
                            const value = properties.val;
                            return value;
                        },
                        'node': function () {
                            const div = this._div;
                            return div;
                        },
                        'redraw': function () {
                            this.resize();
                            const properties = this._properties;
                            const colorTrack = properties.colorBG;
                            const colorFilling = properties.colorFG;
                            const colorMarkers = properties.colorMarkers;
                            const markerStart = properties.markerStart;
                            const markerEnd = properties.markerEnd;
                            const markerStep = properties.markerStep;
                            const trackWidth = properties.trackWidth;
                            const valMin = properties.valMin;
                            const valMax = properties.valMax;
                            const peaks = properties.valPeaks;
                            const value = properties.val;
                            const height = this._height;
                            const width = this._width;
                            const lineWidth = Math.round(trackWidth * height);
                            const halfWidth = 0.5 * lineWidth;
                            const centerY = 0.5 * height;
                            const lineTop = centerY - halfWidth;
                            const lineBottom = centerY + halfWidth;
                            const relativeValue = (value - valMin) / (valMax - valMin);
                            const fillingEnd = width * relativeValue;
                            const numPeaks = peaks.length;
                            const canvas = this._canvas;
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, width, height);
                            if ((markerStart !== null) & (markerEnd !== null) & (markerStep !== null) & (markerStep !== 0)) {
                                ctx.lineCap = 'butt';
                                ctx.lineWidth = '2';
                                ctx.strokeStyle = colorMarkers;
                                for (let v = markerStart; v <= markerEnd; v += markerStep) {
                                    const relativePos = (v - valMin) / (valMax - valMin);
                                    const pos = Math.round(width * relativePos);
                                    ctx.beginPath();
                                    ctx.moveTo(pos, 0);
                                    ctx.lineTo(pos, height);
                                    ctx.stroke();
                                }
                            }
                            ctx.beginPath();
                            ctx.rect(0, lineTop, width, lineWidth);
                            ctx.fillStyle = colorTrack;
                            ctx.fill();
                            ctx.beginPath();
                            ctx.rect(0, lineTop, fillingEnd, lineWidth);
                            ctx.fillStyle = colorFilling;
                            ctx.fill();
                            ctx.strokeStyle = colorFilling;
                            for (let i = 0; i < numPeaks; i++) {
                                const peak = peaks[i];
                                const relativePeak = (peak - valMin) / (valMax - valMin);
                                const pos = Math.round(width * relativePeak);
                                ctx.beginPath();
                                ctx.moveTo(pos, lineTop);
                                ctx.lineTo(pos, lineBottom);
                                ctx.stroke();
                            }
                        },
                        'resize': function () {
                            const canvas = this._canvas;
                            canvas.style.height = '100%';
                            canvas.style.width = '100%';
                            canvas.height = this._height;
                            canvas.width = this._width;
                        },
                        'setPeaks': function (peaks) {
                            const properties = this._properties;
                            const peaksCopy = [];
                            const numPeaks = peaks.length;
                            for (let i = 0; i < numPeaks; i++) {
                                const peak = peaks[i];
                                peaksCopy.push(peak);
                            }
                            this.setProperty('valPeaks', peaksCopy);
                        },
                        'setProperty': function (key, value) {
                            this._properties[key] = value;
                            this.redraw();
                        },
                        'setValue': function (value) {
                            const properties = this._properties;
                            const valMin = properties.valMin;
                            const valMax = properties.valMax;
                            if (value < valMin) {
                                value = valMin;
                            } else if (value > valMax) {
                                value = valMax;
                            }
                            value = Math.round(value);
                            this.setProperty('val', value);
                        }
                    };
                    const resizeListener = function (e) {
                        graph.redraw();
                    };
                    canvas.addEventListener('resize', resizeListener);
                    return graph;
                }
                    ;
                this.createKnob = function (width, height) {
                    const heightString = height.toString();
                    const widthString = width.toString();
                    const smaller = width < height ? width : height;
                    const fontSize = 0.2 * smaller;
                    const fontSizeString = fontSize.toString();
                    const canvas = document.createElement('canvas');
                    const div = document.createElement('div');
                    div.style.display = 'inline-block';
                    div.style.height = heightString + 'px';
                    div.style.position = 'relative';
                    div.style.textAlign = 'center';
                    div.style.width = widthString + 'px';
                    div.appendChild(canvas);
                    const input = document.createElement('input');
                    input.style.appearance = 'textfield';
                    input.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    input.style.border = 'none';
                    input.style.color = '#ff8800';
                    input.style.fontFamily = 'sans-serif';
                    input.style.fontSize = fontSizeString + 'px';
                    input.style.height = heightString + 'px';
                    input.style.margin = 'auto';
                    input.style.padding = '0px';
                    input.style.textAlign = 'center';
                    input.style.width = widthString + 'px';
                    const inputMode = document.createAttribute('inputmode');
                    inputMode.value = 'numeric';
                    input.setAttributeNode(inputMode);
                    const inputDiv = document.createElement('div');
                    inputDiv.style.bottom = '0px';
                    inputDiv.style.display = 'none';
                    inputDiv.style.left = '0px';
                    inputDiv.style.position = 'absolute';
                    inputDiv.style.right = '0px';
                    inputDiv.style.top = '0px';
                    inputDiv.appendChild(input);
                    div.appendChild(inputDiv);
                    const knob = {
                        '_canvas': canvas,
                        '_div': div,
                        '_height': height,
                        '_input': input,
                        '_inputDiv': inputDiv,
                        '_listeners': [],
                        '_mousebutton': false,
                        '_previousVal': 0,
                        '_timeout': null,
                        '_timeoutDoubleTap': null,
                        '_touchCount': 0,
                        '_width': width,
                        '_notifyUpdate': function () {
                            const properties = this._properties;
                            const value = properties.val;
                            const listeners = this._listeners;
                            const numListeners = listeners.length;
                            for (let i = 0; i < numListeners; i++) {
                                const listener = listeners[i];
                                if (listener !== null) {
                                    listener(this, value);
                                }
                            }
                        },
                        '_properties': {
                            'angleEnd': 0.75 * Math.PI,
                            'angleOffset': -0.5 * Math.PI,
                            'angleStart': -0.75 * Math.PI,
                            'colorBG': '#181818',
                            'colorFG': '#ff8800',
                            'colorLabel': '#333',
                            'fnStringToValue': function (string) {
                                return parseInt(string);
                            },
                            'fnValueToString': function (value) {
                                return value.toString();
                            },
                            'label': null,
                            'needle': false,
                            'readonly': false,
                            'textScale': 1.0,
                            'trackWidth': 0.4,
                            'valMin': 0,
                            'valMax': 100,
                            'val': 0
                        },
                        'abort': function () {
                            const previousValue = this._previousVal;
                            const properties = this._properties;
                            properties.val = previousValue;
                            this.redraw();
                        },
                        'addListener': function (listener) {
                            const listeners = this._listeners;
                            listeners.push(listener);
                        },
                        'commit': function () {
                            const properties = this._properties;
                            const value = properties.val;
                            this._previousVal = value;
                            this.redraw();
                            this._notifyUpdate();
                        },
                        'getProperty': function (key) {
                            const properties = this._properties;
                            const value = properties[key];
                            return value;
                        },
                        'getValue': function () {
                            const properties = this._properties;
                            const value = properties.val;
                            return value;
                        },
                        'node': function () {
                            const div = this._div;
                            return div;
                        },
                        'redraw': function () {
                            this.resize();
                            const properties = this._properties;
                            const needle = properties.needle;
                            const angleStart = properties.angleStart;
                            const angleOffset = properties.angleOffset;
                            const angleEnd = properties.angleEnd;
                            const actualStart = angleStart + angleOffset;
                            const actualEnd = angleEnd + angleOffset;
                            const label = properties.label;
                            const value = properties.val;
                            const valueToString = properties.fnValueToString;
                            const valueStr = valueToString(value);
                            const valMin = properties.valMin;
                            const valMax = properties.valMax;
                            const relValue = (value - valMin) / (valMax - valMin);
                            const relAngle = relValue * (angleEnd - angleStart);
                            const angleVal = actualStart + relAngle;
                            const colorTrack = properties.colorBG;
                            const colorFilling = properties.colorFG;
                            const colorLabel = properties.colorLabel;
                            const textScale = properties.textScale;
                            const trackWidth = properties.trackWidth;
                            const height = this._height;
                            const width = this._width;
                            const smaller = width < height ? width : height;
                            const centerX = 0.5 * width;
                            const centerY = 0.5 * height;
                            const radius = 0.4 * smaller;
                            const labelY = centerY + radius;
                            const lineWidth = Math.round(trackWidth * radius);
                            const labelSize = Math.round(0.8 * lineWidth);
                            const labelSizeString = labelSize.toString();
                            const fontSize = (0.2 * smaller) * textScale;
                            const fontSizeString = fontSize.toString();
                            const canvas = this._canvas;
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, width, height);
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius, actualStart, actualEnd);
                            ctx.lineCap = 'butt';
                            ctx.lineWidth = lineWidth;
                            ctx.strokeStyle = colorTrack;
                            ctx.stroke();
                            ctx.beginPath();
                            if (needle) {
                                ctx.arc(centerX, centerY, radius, angleVal - 0.1, angleVal + 0.1);
                            } else {
                                ctx.arc(centerX, centerY, radius, actualStart, angleVal);
                            }
                            ctx.lineCap = 'butt';
                            ctx.lineWidth = lineWidth;
                            ctx.strokeStyle = colorFilling;
                            ctx.stroke();
                            ctx.font = fontSizeString + 'px sans-serif';
                            ctx.fillStyle = colorFilling;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(valueStr, centerX, centerY);
                            if (label !== null) {
                                ctx.font = labelSizeString + 'px sans-serif';
                                ctx.fillStyle = colorLabel;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(label, centerX, labelY);
                            }
                            const elemInput = this._input;
                            elemInput.style.color = colorFilling;
                            elemInput.style.fontSize = fontSizeString + 'px';
                        },
                        'resize': function () {
                            const canvas = this._canvas;
                            canvas.style.height = '100%';
                            canvas.style.width = '100%';
                            canvas.height = this._height;
                            canvas.width = this._width;
                        },
                        'setProperty': function (key, value) {
                            this._properties[key] = value;
                            this.redraw();
                        },
                        'setValue': function (value) {
                            this.setValueFloating(value);
                            this.commit();
                        },
                        'setValueFloating': function (value) {
                            const properties = this._properties;
                            const valMin = properties.valMin;
                            const valMax = properties.valMax;
                            if (value < valMin) {
                                value = valMin;
                            } else if (value > valMax) {
                                value = valMax;
                            }
                            value = Math.round(value);
                            this.setProperty('val', value);
                        }
                    };
                    const mouseEventToValue = function (e, properties) {
                        const canvas = e.target;
                        const width = canvas.scrollWidth;
                        const height = canvas.scrollHeight;
                        const centerX = 0.5 * width;
                        const centerY = 0.5 * height;
                        const x = e.offsetX;
                        const y = e.offsetY;
                        const relX = x - centerX;
                        const relY = y - centerY;
                        const angleStart = properties.angleStart;
                        const angleEnd = properties.angleEnd;
                        const angleDiff = angleEnd - angleStart;
                        let angle = Math.atan2(relX, -relY) - angleStart;
                        const twoPi = 2.0 * Math.PI;
                        if (angle < 0) {
                            if (angleDiff >= twoPi) {
                                angle += twoPi;
                            } else {
                                angle = 0;
                            }
                        }
                        const valMin = properties.valMin;
                        const valMax = properties.valMax;
                        let value = ((angle / angleDiff) * (valMax - valMin)) + valMin;
                        if (value < valMin) {
                            value = valMin;
                        } else if (value > valMax) {
                            value = valMax;
                        }
                        return value;
                    };
                    const touchEventToValue = function (e, properties) {
                        const canvas = e.target;
                        const rect = canvas.getBoundingClientRect();
                        const offsetX = rect.left;
                        const offsetY = rect.top;
                        const width = canvas.scrollWidth;
                        const height = canvas.scrollHeight;
                        const centerX = 0.5 * width;
                        const centerY = 0.5 * height;
                        const touches = e.targetTouches;
                        let touch = null;
                        if (touches.length > 0) {
                            touch = touches.item(0);
                        }
                        let x = 0.0;
                        let y = 0.0;
                        if (touch !== null) {
                            const touchX = touch.pageX;
                            x = touchX - offsetX;
                            const touchY = touch.pageY;
                            y = touchY - offsetY;
                        }
                        const relX = x - centerX;
                        const relY = y - centerY;
                        const angleStart = properties.angleStart;
                        const angleEnd = properties.angleEnd;
                        const angleDiff = angleEnd - angleStart;
                        const twoPi = 2.0 * Math.PI;
                        let angle = Math.atan2(relX, -relY) - angleStart;
                        if (angle < 0) {
                            if (angleDiff >= twoPi) {
                                angle += twoPi;
                            } else {
                                angle = 0;
                            }
                        }
                        const valMin = properties.valMin;
                        const valMax = properties.valMax;
                        let value = ((angle / angleDiff) * (valMax - valMin)) + valMin;
                        if (value < valMin) {
                            value = valMin;
                        } else if (value > valMax) {
                            value = valMax;
                        }
                        return value;
                    };
                    const doubleClickListener = function (e) {
                        const properties = knob._properties;
                        const readonly = properties.readonly;
                        if (!readonly) {
                            e.preventDefault();
                            const inputDiv = knob._inputDiv;
                            inputDiv.style.display = 'block';
                            const inputElem = knob._input;
                            inputElem.focus();
                            knob.redraw();
                        }
                    };
                    const mouseDownListener = function (e) {
                        const btn = e.buttons;
                        if (btn === 1) {
                            const properties = knob._properties;
                            const readonly = properties.readonly;
                            if (!readonly) {
                                e.preventDefault();
                                const val = mouseEventToValue(e, properties);
                                knob.setValueFloating(val);
                            }
                            knob._mousebutton = true;
                        }
                        if (btn === 4) {
                            const properties = knob._properties;
                            const readonly = properties.readonly;
                            if (!readonly) {
                                e.preventDefault();
                                const inputDiv = knob._inputDiv;
                                inputDiv.style.display = 'block';
                                const inputElem = knob._input;
                                inputElem.focus();
                                knob.redraw();
                            }
                        }
                    };
                    const mouseMoveListener = function (e) {
                        const btn = knob._mousebutton;
                        if (btn) {
                            const properties = knob._properties;
                            const readonly = properties.readonly;
                            if (!readonly) {
                                e.preventDefault();
                                const val = mouseEventToValue(e, properties);
                                knob.setValueFloating(val);
                            }
                        }
                    };
                    const mouseUpListener = function (e) {
                        const btn = knob._mousebutton;
                        if (btn) {
                            const properties = knob._properties;
                            const readonly = properties.readonly;
                            if (!readonly) {
                                e.preventDefault();
                                const val = mouseEventToValue(e, properties);
                                knob.setValue(val);
                            }
                        }
                        knob._mousebutton = false;
                    };
                    const mouseCancelListener = function (e) {
                        const btn = knob._mousebutton;
                        if (btn) {
                            knob.abort();
                            knob._mousebutton = false;
                        }
                    };
                    const touchStartListener = function (e) {
                        const properties = knob._properties;
                        const readonly = properties.readonly;
                        if (!readonly) {
                            const touches = e.targetTouches;
                            const numTouches = touches.length;
                            const singleTouch = (numTouches === 1);
                            if (singleTouch) {
                                knob._mousebutton = true;
                                if (knob._touchCount === 0) {
                                    const f = function () {
                                        if (knob._touchCount === 2) {
                                            const properties = knob._properties;
                                            const readonly = properties.readonly;
                                            if (!readonly) {
                                                e.preventDefault();
                                                const inputDiv = knob._inputDiv;
                                                inputDiv.style.display = 'block';
                                                const inputElem = knob._input;
                                                inputElem.focus();
                                                knob.redraw();
                                            }
                                        }
                                        knob._touchCount = 0;
                                    };
                                    let timeout = knob._timeoutDoubleTap;
                                    window.clearTimeout(timeout);
                                    timeout = window.setTimeout(f, 500);
                                    knob._timeoutDoubleTap = timeout;
                                }
                                knob._touchCount++;
                                const val = touchEventToValue(e, properties);
                                knob.setValueFloating(val);
                            }
                        }
                    };
                    var touchMoveListener = function (e) {
                        const btn = knob._mousebutton;
                        if (btn) {
                            const properties = knob._properties;
                            const readonly = properties.readonly;
                            if (!readonly) {
                                const touches = e.targetTouches;
                                const numTouches = touches.length;
                                const singleTouch = (numTouches === 1);
                                if (singleTouch) {
                                    e.preventDefault();
                                    const val = touchEventToValue(e, properties);
                                    knob.setValueFloating(val);
                                }
                            }
                        }
                    };
                    const touchEndListener = function (e) {
                        const btn = knob._mousebutton;
                        if (btn) {
                            const properties = knob._properties;
                            const readonly = properties.readonly;
                            if (!readonly) {
                                const touches = e.targetTouches;
                                const numTouches = touches.length;
                                const noMoreTouches = (numTouches === 0);
                                if (noMoreTouches) {
                                    e.preventDefault();
                                    knob._mousebutton = false;
                                    knob.commit();
                                }
                            }
                        }
                        knob._mousebutton = false;
                    };
                    const touchCancelListener = function (e) {
                        const btn = knob._mousebutton;
                        if (btn) {
                            knob.abort();
                            knob._touchCount = 0;
                            const timeout = knob._timeoutDoubleTap;
                            window.clearTimeout(timeout);
                        }
                        knob._mousebutton = false;
                    };
                    const resizeListener = function (e) {
                        knob.redraw();
                    };
                    const scrollListener = function (e) {
                        const readonly = knob.getProperty('readonly');
                        if (!readonly) {
                            e.preventDefault();
                            const delta = e.deltaY;
                            const direction = delta > 0 ? 1 : (delta < 0 ? -1 : 0);
                            let val = knob.getValue();
                            val += direction;
                            knob.setValueFloating(val);
                            const commit = function () {
                                knob.commit();
                            };
                            let timeout = knob._timeout;
                            window.clearTimeout(timeout);
                            timeout = window.setTimeout(commit, 250);
                            knob._timeout = timeout;
                        }
                    };
                    const keyPressListener = function (e) {
                        const kc = e.keyCode;
                        if ((kc === 13) || (kc === 27)) {
                            const inputDiv = knob._inputDiv;
                            inputDiv.style.display = 'none';
                            const input = e.target;
                            if (kc === 13) {
                                const properties = knob._properties;
                                const value = input.value;
                                const stringToValue = properties.fnStringToValue;
                                const val = stringToValue(value);
                                const valid = isFinite(val);
                                if (valid) {
                                    knob.setValue(val);
                                }
                            }
                            input.value = '';
                        }
                    };
                    canvas.addEventListener('dblclick', doubleClickListener);
                    canvas.addEventListener('mousedown', mouseDownListener);
                    canvas.addEventListener('mouseleave', mouseCancelListener);
                    canvas.addEventListener('mousemove', mouseMoveListener);
                    canvas.addEventListener('mouseup', mouseUpListener);
                    canvas.addEventListener('resize', resizeListener);
                    canvas.addEventListener('touchstart', touchStartListener);
                    canvas.addEventListener('touchmove', touchMoveListener);
                    canvas.addEventListener('touchend', touchEndListener);
                    canvas.addEventListener('touchcancel', touchCancelListener);
                    canvas.addEventListener('wheel', scrollListener);
                    input.addEventListener('keypress', keyPressListener);
                    return knob;
                }
                    ;
            }
            return new PureKnob();
        }));
    </script>
    <script>
        const rtemp = pureknob.createKnob(300, 300);
        const stemp = pureknob.createKnob(300, 300);
        const rhumi = pureknob.createKnob(300, 300);
        const shumi = pureknob.createKnob(300, 300);
        const day = pureknob.createKnob(300, 300);
        const CO2 = pureknob.createKnob(300, 300);
        function rtempKnob() {
            rtemp.setProperty('colorFG', '#8B2B17');
            rtemp.setProperty('readonly', true);
            rtemp.setProperty('label', "Degrees");
            const node = rtemp.node();
            const elem = document.getElementById('rtemp');
            elem.appendChild(node);
        }
        ; function stempKnob() {
            stemp.setProperty('colorFG', '#FF3004');
            stemp.setProperty('label', "Degrees");
            const listener = function (stemp, value) {
                console.log("Pushedtemp is: " + value);
                Pushedtemp = value;
            };
            stemp.addListener(listener);
            const node = stemp.node();
            const elem = document.getElementById('stemp');
            elem.appendChild(node);
        }
        ; function rhumiKnob() {
            rhumi.setProperty('colorFG', '#0068FF');
            rhumi.setProperty('readonly', true);
            rhumi.setProperty('label', "%");
            const node = rhumi.node();
            const elem = document.getElementById('rhumi');
            elem.appendChild(node);
        }
        ; function dayKnob() {
            day.setProperty('colorFG', '#32CD32');
            day.setProperty('label', "Hours per Day");
            day.setProperty('valMax', "24");
            const listener = function (day, value) {
                console.log("Pushedday is: " + value);
                Pushedday = value;
            };
            day.addListener(listener);
            const node = day.node();
            const elem = document.getElementById('day');
            elem.appendChild(node);
        }
        ; function CO2Knob() {
            CO2.setProperty('colorFG', '#808080');
            CO2.setProperty('label', "ppm");
            CO2.setProperty('readonly', true);
            CO2.setProperty('valmin', "300");
            CO2.setProperty('valMax', "3000");
            const node = CO2.node();
            const elem = document.getElementById('CO2');
            elem.appendChild(node);
        };
        function shumiKnob() {
            shumi.setProperty('colorFG', '#154C9C');
            shumi.setProperty('label', "% ");
            const listener = function (shumi, value) {
                console.log("Pushedhumi is: " + value);
                Pushedhumi = value;
            };
            shumi.addListener(listener);
            const node = shumi.node();
            const elem = document.getElementById('shumi');
            elem.appendChild(node);
        };


        PulledTemp = 0;
        Pulledhumi = 0;
        PulledCO2 = 0;
        Pushedtemp = 0;
        Pushedhumi = 0;
        Pushedday = 0;
        Pushedtemp1 = 0;
        Pushedhumi1 = 0;
        Pushedday1 = 0;

        function sres(frot) {
            Pushedtemp1 = Pushedtemp;
            Pushedhumi1 = Pushedhumi;
            Pushedday1 = Pushedday;
            stemp.setValue(recipe[frot].temp);
            shumi.setValue(recipe[frot].humi);
            day.setValue(recipe[frot].day);
        }
    </script>
    <script>
        function update() {
            $.get("./update", function () { }, "jsonp");
        }
        function getRecipe() {
            $.ajax({
                url: "https://s437000475.github.io/API/", dataType: "json", success: function (data) {
                    recipe = data;
                    var RecipeDropDown = '';
                    for (i = 1; i < Object.keys(data).length; i++) {
                        RecipeDropDown = RecipeDropDown + "<li><a onclick=\"sres('" + Object.keys(data)[i] + "')\">" + Object.keys(data)[i] + "</a></li>" + "\n";
                    }
                    var d1 = document.getElementById('RecipeDropDown');
                    d1.insertAdjacentHTML('beforeend', RecipeDropDown);
                    sres('Default');
                }
            });
        }
        ;
        function Apply() {
            Pushedtemp1 = Pushedtemp;
            Pushedhumi1 = Pushedhumi;
            Pushedday1 = Pushedday;
            $.get("./set?Pushedtemp=" + String(Pushedtemp) + "&Pushedhumi=" + String(Pushedhumi) + "&Pushedday=" + String(Pushedday), function () { }, "jsonp"); //send to the ESP32
        };
        function Reset() {
            stemp.setValue(Pushedtemp1);
            shumi.setValue(Pushedhumi1);
            day.setValue(Pushedday1);
        };
        function ready() {
            rtempKnob();
            stempKnob();
            rhumiKnob();
            shumiKnob();
            dayKnob();
            CO2Knob();
            getRecipe();
            update();
            $("#Manager").hide();
            window.setInterval(update, 10000);
        }
        ; document.addEventListener('DOMContentLoaded', ready, false);

        function hideLive() {
            $("#Live").fadeOut(200, function () {
                $("#Manager").fadeIn(200);
                $("#NavManager").addClass("active");
                $("#NavLive").removeClass("active");
                document.getElementById('page1').innerHTML = '';
                document.getElementById('page2').innerHTML = '<div class="container-fluid"><div class="col-lg-3 col-md-4"><h3>Set Temperature</h3><p id="stemp"></p></div><div class="col-lg-3 col-md-4"><h3>Set Humidity</h3><p id="shumi"></p></div><div class="col-lg-3 col-md-4"><h3>Light Duration</h3><p id="day"></p></div></div>';
                shumiKnob();
                dayKnob();
                stempKnob();
            });

        }
        function hideManager() {
            $("#Manager").fadeOut(200, function () {
                $("#Live").fadeIn(200);
                $("#NavManager").addClass("active");
                $("#NavLive").removeClass("active");
                $("#NavLive").addClass("active");
                $("#NavManager").removeClass("active");
                document.getElementById('page2').innerHTML = '';
                document.getElementById('page1').innerHTML = '<div class="col-md-4"><h3>Set Temperature</h3><p id="stemp"></p></div><div class="col-md-4"><h3>Set Humidity</h3><p id="shumi"></p></div><div class="col-md-4"><h3>Light Duration</h3><p id="day"></p></div>';
                shumiKnob();
                dayKnob();
                stempKnob();
            });
            update();
        }
    </script>
</head>

<body>
    <nav class="navbar navbar-default">
        <div class="container-fluid">
            <div class="navbar-header">
                <a class="navbar-brand" href="./index.html">Green Land</a>
            </div>
            <ul class="nav navbar-nav">
                <li id="NavLive" class="active"><a onclick="hideManager();">Live Data</a></li>
                <li id="NavManager"><a onclick="hideLive();">Recipes Manager</a></li>
                <li><a class="dropdown-toggle" data-toggle="dropdown"> Select Recipe
                        <span class="caret"></span></a>
                    <ul class="dropdown-menu" id="RecipeDropDown">
                    </ul>
                </li>
            </ul>
        </div>
    </nav>
    <div class="container" id="Live">
        <div class="container">
            <div class="row">
                <div class="col-md-4">
                    <h3>Current Temperature</h3>
                    <p id="rtemp"></p>
                </div>
                <div class="col-md-4">
                    <h3>Current Humidity</h3>
                    <p id="rhumi"></p>
                </div>
                <div class="col-md-4">
                    <h3>CO2 Levels</h3>
                    <p id="CO2"></p>
                </div>
            </div>
        </div>
        <div class="container">
            <div class="row" id="page1">
                <div class="col-md-4">
                    <h3>Set Temperature</h3>
                    <p id="stemp"></p>
                </div>
                <div class="col-md-4">
                    <h3>Set Humidity</h3>
                    <p id="shumi"></p>
                </div>
                <div class="col-md-4">
                    <h3>Light Duration</h3>
                    <p id="day"></p>
                </div>
            </div>
        </div>
        <br>
        <br>
        <div class="container">
            <div class="row">
                <span class="pull-right col-sm-1"></span>
                <button onclick="Apply();" type="button" class="btn btn-default pull-right">Apply</button>
                <span class="pull-right">&nbsp;&nbsp;&nbsp;&nbsp;</span>
                <button onclick="Reset();" type="button" class="btn btn-default pull-right">Reset</button>
            </div>
        </div>
    </div>
    <div class="container-fluid" id="Manager">
        <div class="col-md-3">
            <ul class="nav nav-pills nav-stacked red">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#">Menu 1</a></li>
                <li><a href="#">Menu 2</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>
                <li><a href="#">Menu 3</a></li>

            </ul>
        </div>
        <div class="container-fluid">
  
            <div class="row" id="page2">

            </div>
        </div>

    </div>
</body>

</html>
